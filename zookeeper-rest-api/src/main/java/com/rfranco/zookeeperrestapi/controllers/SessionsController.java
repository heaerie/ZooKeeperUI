package com.rfranco.zookeeperrestapi.controllers;

import com.rfranco.zookeeperrestapi.autogenerated.api.SessionsApi;
import com.rfranco.zookeeperrestapi.autogenerated.dtos.UserCredentials;
import com.rfranco.zookeeperrestapi.autogenerated.dtos.UserSession;
import com.rfranco.zookeeperrestapi.exceptions.UnauthorizedException;
import com.rfranco.zookeeperrestapi.services.CookieAuthenticationService;
import io.swagger.annotations.ApiParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.security.Principal;
import java.util.Date;
import java.util.stream.Collectors;

/**
 * Created by ruben.martinez on 01/12/2017.
 */
@RestController
public class SessionsController implements SessionsApi {
    @Autowired
    UserDetailsService userDetailsService;

    @Autowired
    CookieAuthenticationService cookieAuthenticationService;

    @Autowired
    private HttpServletRequest request;

    @Value(value="${jwt.timeout_seconds}")
    private int jwtTimeout;

    @Override
    public ResponseEntity<Void> closeSession() {
        return ResponseEntity.status(HttpStatus.NO_CONTENT)
                .header("Set-Cookie", cookieAuthenticationService.getAuthenticationRemovalCookie())
                .build();
    }

    @Override
    public ResponseEntity<UserSession> createNewUserSession(@ApiParam(value = "The user credentials used create a new user session.", required = true) @Valid @RequestBody UserCredentials userCredentials) {
        return composeUserSessionResponse(userCredentials.getUserName(), (userDetails) ->
            userDetails.getPassword().equals(userCredentials.getPassword()));
    }

    @Override
    public ResponseEntity<UserSession> getSessionInfo() {
        Principal userPrincipal = request.getUserPrincipal();
        if (userPrincipal == null || !(userPrincipal instanceof UsernamePasswordAuthenticationToken))
            throw new UnauthorizedException("An invalid or no access cookie has been provided.");

        return composeUserSessionResponse((UsernamePasswordAuthenticationToken) userPrincipal);
    }

    @Override
    public ResponseEntity<UserSession> refreshSession() {
        Principal userPrincipal = request.getUserPrincipal();
        if (userPrincipal == null)
            throw new UnauthorizedException("An invalid or no access cookie has been provided.");
        return composeUserSessionResponse(userPrincipal.getName(), null);
    }

    private ResponseEntity<UserSession> composeUserSessionResponse(String userName, UserDetailsValidator validator) {
        try {
            UserDetails userDetails = userDetailsService.loadUserByUsername(userName);
            if (validator != null && !validator.areValid(userDetails)) {
                throw new UnauthorizedException("The provided user credentials are invalid.");
            }
            ResponseEntity<UserSession> response = ResponseEntity.status(HttpStatus.OK)
                    .header("Set-Cookie", cookieAuthenticationService.createAuthenticationCookie(userDetails))
                    .body(new UserSession()
                            .claims(userDetails.getAuthorities().stream().map(authority -> authority.getAuthority())
                                    .collect(Collectors.toList()))
                            .expirationSeconds(jwtTimeout));

            return response;
        }
        catch(UsernameNotFoundException ex) {
            throw new UnauthorizedException("The provided user credentials are invalid.");
        }
    }

    private ResponseEntity<UserSession> composeUserSessionResponse(UsernamePasswordAuthenticationToken authentication) {
        try {
            ResponseEntity.BodyBuilder responseBuilder = ResponseEntity.status(HttpStatus.OK);
            UserSession userSession = new UserSession()
                    .claims(authentication.getAuthorities().stream().map(authority -> authority.getAuthority())
                            .collect(Collectors.toList()));

            if (authentication.getDetails() != null && authentication.getDetails() instanceof Date) {
                long expirationSeconds = (((Date) authentication.getDetails()).getTime() - (new Date().getTime())) / 1000;
                userSession.setExpirationSeconds((int) expirationSeconds);
            }

            return responseBuilder.body(userSession);
        }
        catch(UsernameNotFoundException ex) {
            throw new UnauthorizedException("The provided user credentials are invalid.");
        }
    }

    interface UserDetailsValidator {
        boolean areValid(UserDetails userDetails);
    }
}
