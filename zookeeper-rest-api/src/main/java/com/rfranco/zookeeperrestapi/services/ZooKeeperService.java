package com.rfranco.zookeeperrestapi.services;

import com.rfranco.zookeeperrestapi.autogenerated.dtos.NodeCreationRequest;
import com.rfranco.zookeeperrestapi.autogenerated.dtos.NodeExport;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Created by ruben.martinez on 21/11/2017.
 */
@Service
public class ZooKeeperService {
    @Autowired
    private CuratorFramework zooKeeperClient;

    public List<String> getNodeChildren(String path) throws Exception {
        GetChildrenBuilder builder = zooKeeperClient.getChildren();
        List<String> children = builder.forPath(path);
        if (path.equals("/")) {
            children.remove("zookeeper");
        }
        return children;
    }

    public String getNodeData(String path) throws Exception {
        return new String(zooKeeperClient.getData().forPath(path), "UTF-8");
    }

    public void setNodeData(String path, String value) throws Exception {
        zooKeeperClient.setData().forPath(path, value.getBytes("UTF-8"));
    }

    public void deleteNode(String path) throws Exception {
        zooKeeperClient.delete().deletingChildrenIfNeeded().forPath(path);
    }

    public void addNode(String path, NodeCreationRequest body) throws Exception {
        if (!path.endsWith("/"))
            path += "/";
        path += body.getName();

        String data =  body.getData() != null ?  body.getData() : "";
        zooKeeperClient.inTransaction().create().forPath(path, data.getBytes("UTF-8")).and().commit();
    }

    public NodeExport getNodeExport(String path) throws Exception {
        NodeExport export = new NodeExport()
                .name(getNodeNameFromPath(path))
                .value(getNodeData(path));
        List<String> children = getNodeChildren(path);
        for (String childName: children) {
            export.addChildrenItem(getNodeExport(appendSegmentToNodePath(path, childName)));
        }
        return export;
    }

    public void restoreNodeExport(String path, NodeExport node, Boolean prune, Boolean overwrite) throws Exception{
        if (zooKeeperClient.checkExists().forPath(path) != null) {
            if (overwrite)
                zooKeeperClient.setData().forPath(path, node.getValue().getBytes("UTF-8"));
        } else {
            zooKeeperClient.create().forPath(path, node.getValue().getBytes("UTF-8"));
        }

        if (prune) {
            List<String> alreadyExistingChildren =  getNodeChildren(path);
            String[] existingChildrenNotInExport = alreadyExistingChildren.stream().filter(
                    alreadyExistingChild -> !node.getChildren().stream().anyMatch(
                        importedNodeChild -> importedNodeChild.getName().equals(alreadyExistingChild))
                ).toArray(size -> new String[size]);

            for (String childNotInExport: existingChildrenNotInExport) {
                deleteNode(appendSegmentToNodePath(path, childNotInExport));
            }
        }

        for (NodeExport childNode: node.getChildren()) {
            restoreNodeExport(appendSegmentToNodePath(path, childNode.getName()), childNode, prune, overwrite);
        }
    }

    private static String appendSegmentToNodePath(String path, String segment) {
        String result = path;
        if (!result.endsWith("/"))
            result += "/";

        result += segment;

        return result;
    }

    private static String getNodeNameFromPath(String path) {
        String[] pathSegments = path.split("/");

        if (pathSegments.length == 0)
            return "Root";

        return pathSegments[pathSegments.length - 1];
    }
}
