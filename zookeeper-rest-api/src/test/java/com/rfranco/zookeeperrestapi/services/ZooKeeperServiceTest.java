package com.rfranco.zookeeperrestapi.services;

import com.rfranco.zookeeperrestapi.autogenerated.dtos.NodeExport;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.api.*;
import org.apache.zookeeper.data.Stat;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.Optional;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

/**
 * Created by ruben.martinez on 24/11/2017.
 */
public class ZooKeeperServiceTest {
    @Mock
    private CuratorFramework zooKeeperClient;

    @Mock
    private GetChildrenBuilder getChildrenBuilder;

    @Mock
    private GetDataBuilder getDataBuilder;

    @Mock
    private SetDataBuilder setDataBuilder;

    @Mock
    private DeleteBuilder deleteBuilder;

    @Mock
    private ExistsBuilder existsBuilder;

    @Mock
    private CreateBuilder createBuilder;

    @InjectMocks
    private ZooKeeperService zooKeeperService;

    @Before
    public void init() {
        MockitoAnnotations.initMocks(this);
        doReturn(getChildrenBuilder).when(zooKeeperClient).getChildren();
        doReturn(getDataBuilder).when(zooKeeperClient).getData();
        doReturn(setDataBuilder).when(zooKeeperClient).setData();
        doReturn(existsBuilder).when(zooKeeperClient).checkExists();
        doReturn(deleteBuilder).when(zooKeeperClient).delete();
        doReturn(createBuilder).when(zooKeeperClient).create();
        doReturn(deleteBuilder).when(deleteBuilder).deletingChildrenIfNeeded();
    }

    @Test
    public void SuccessfulNodeExport() throws Exception {
        doReturn(Arrays.asList("childNode1", "childNode2")).when(getChildrenBuilder).forPath("/");
        doReturn(Arrays.asList("childNode1_1")).when(getChildrenBuilder).forPath("/childNode1");
        doReturn(Arrays.asList()).when(getChildrenBuilder).forPath("/childNode2");
        doReturn(Arrays.asList()).when(getChildrenBuilder).forPath("/childNode1/childNode1_1");

        doReturn("".getBytes()).when(getDataBuilder).forPath("/");
        doReturn("childNode1Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode1");
        doReturn("childNode1_1Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode1/childNode1_1");
        doReturn("childNode2Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode2");

        NodeExport expectedExport = new NodeExport().name("Root").value("");
        expectedExport.addChildrenItem(new NodeExport().name("childNode1").value("childNode1Data").addChildrenItem(
                new NodeExport().name("childNode1_1").value("childNode1_1Data")
        ));
        expectedExport.addChildrenItem(new NodeExport().name("childNode2").value("childNode2Data"));

        NodeExport obtainedExport = zooKeeperService.getNodeExport("/");
        assertNodeExportsAreEqual(expectedExport, obtainedExport);
    }

    @Test
    public void NodeExportRestorationDoesNotOverrideValuesNorPruneWhenConfiguredToDoSo() throws Exception {
        NodeExport testExport = setupCommonScenarioWith3NodesInExportAnd4ActualNodes();

        zooKeeperService.restoreNodeExport("/", testExport, false, false);
        verify(setDataBuilder, never()).forPath(any(String.class), any(byte[].class));
        verify(deleteBuilder, never()).forPath(any(String.class));
    }

    @Test
    public void NodeExportRestorationOverridesValuesWhenConfiguredToDoSo() throws Exception {
        NodeExport testExport = setupCommonScenarioWith3NodesInExportAnd4ActualNodes();

        zooKeeperService.restoreNodeExport("/", testExport, false, true);
        verify(setDataBuilder, times(3)).forPath(any(String.class), any(byte[].class));
        verify(setDataBuilder, times(1)).forPath("/", "".getBytes("UTF-8"));
        verify(setDataBuilder, times(1)).forPath("/childNode1", "childNode1Data".getBytes("UTF-8"));
        verify(setDataBuilder, times(1)).forPath("/childNode2", "childNode2Data".getBytes("UTF-8"));
    }

    @Test
    public void NodeExportRestorationPrunesWhenConfiguredToDoSo() throws Exception {
        NodeExport testExport = setupCommonScenarioWith3NodesInExportAnd4ActualNodes();

        zooKeeperService.restoreNodeExport("/", testExport, true, false);
        verify(deleteBuilder, times(1)).forPath(any());
        verify(deleteBuilder, times(1)).forPath("/childNode1/childNode1_1");
    }

    @Test
    public void NodeExportRestorationCreatesMissingNodes() throws Exception {
        NodeExport testExport = setupCommonScenarioWith4NodesInExportAnd3ActualNodes();

        zooKeeperService.restoreNodeExport("/", testExport, false, false);
        verify(createBuilder, times(1)).forPath(any(String.class), any(byte[].class));
        verify(createBuilder).forPath("/childNode1/childNode1_1", "childNode1_1Data".getBytes("UTF-8"));
    }

    private NodeExport setupCommonScenarioWith3NodesInExportAnd4ActualNodes() throws Exception {
        doReturn(new Stat()).when(existsBuilder).forPath("/");
        doReturn(new Stat()).when(existsBuilder).forPath("/childNode1");
        doReturn(new Stat()).when(existsBuilder).forPath("/childNode2");
        doReturn(new Stat()).when(existsBuilder).forPath("/childNode1/childNode1_1");

        doReturn(Arrays.asList("childNode1", "childNode2")).when(getChildrenBuilder).forPath("/");
        doReturn(Arrays.asList("childNode1_1")).when(getChildrenBuilder).forPath("/childNode1");
        doReturn(Arrays.asList()).when(getChildrenBuilder).forPath("/childNode2");
        doReturn(Arrays.asList()).when(getChildrenBuilder).forPath("/childNode1/childNode1_1");

        doReturn("".getBytes()).when(getDataBuilder).forPath("/");
        doReturn("childNode1Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode1");
        doReturn("childNode1_1Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode1/childNode1_1");
        doReturn("childNode2Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode2");

        NodeExport testExport = new NodeExport().name("Root").value("");
        testExport.addChildrenItem(new NodeExport().name("childNode1").value("childNode1Data"));
        testExport.addChildrenItem(new NodeExport().name("childNode2").value("childNode2Data"));
        return testExport;
    }

    private NodeExport setupCommonScenarioWith4NodesInExportAnd3ActualNodes() throws Exception {
        doReturn(new Stat()).when(existsBuilder).forPath("/");
        doReturn(new Stat()).when(existsBuilder).forPath("/childNode1");
        doReturn(new Stat()).when(existsBuilder).forPath("/childNode2");

        doReturn(Arrays.asList("childNode1", "childNode2")).when(getChildrenBuilder).forPath("/");
        doReturn(Arrays.asList("childNode1_1")).when(getChildrenBuilder).forPath("/childNode1");
        doReturn(Arrays.asList()).when(getChildrenBuilder).forPath("/childNode2");

        doReturn("".getBytes()).when(getDataBuilder).forPath("/");
        doReturn("childNode1Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode1");
        doReturn("childNode2Data".getBytes("UTF-8")).when(getDataBuilder).forPath("/childNode2");

        NodeExport testExport = new NodeExport().name("Root").value("");
        testExport.addChildrenItem(new NodeExport().name("childNode1").value("childNode1Data").addChildrenItem(
                new NodeExport().name("childNode1_1").value("childNode1_1Data")));
        testExport.addChildrenItem(new NodeExport().name("childNode2").value("childNode2Data"));
        return testExport;
    }

    private static void assertNodeExportsAreEqual(NodeExport expectedExport, NodeExport obtainedExport) {
        Assert.assertEquals(expectedExport.getName(), obtainedExport.getName());
        Assert.assertEquals(expectedExport.getValue(), obtainedExport.getValue());
        for (NodeExport expectedChild: expectedExport.getChildren()) {
            Optional<NodeExport> obtainedChild = obtainedExport.getChildren().stream()
                    .filter(child -> child.getName().equals(expectedChild.getName())).findFirst();
            Assert.assertTrue(obtainedChild.isPresent());
            assertNodeExportsAreEqual(expectedChild, obtainedChild.get());
        }
    }
}