/**
 * ZooKeeper REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ConfigApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Creates a new child of the given data node.
     * Creates a new child of the given data node.
     * @param nodePath The path of the node that will be added a child (with ~ instead of /).
     * @param body The data of the new node (name and value).
     */
    public addNodeChild(nodePath: string, body?: models.NodeCreationRequest, extraHttpRequestParams?: any): Observable<{}> {
        return this.addNodeChildWithHttpInfo(nodePath, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes the given data node.
     * Deletes the given data node.
     * @param nodePath The path of the node whose data will be deleted  (with ~ instead of /).
     */
    public deleteNode(nodePath: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteNodeWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the children of the given data node.
     * Retrieves the children of the given data node.
     * @param nodePath The path of the node whose children will be retrieved (with ~ instead of /).
     */
    public getNodeChildren(nodePath: string, extraHttpRequestParams?: any): Observable<models.ChildrenNodes> {
        return this.getNodeChildrenWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the data of the given data node.
     * Retrieves the data of the given data node.
     * @param nodePath The path of the node whose data will be retrieved  (with ~ instead of /).
     */
    public getNodeData(nodePath: string, extraHttpRequestParams?: any): Observable<models.NodeData> {
        return this.getNodeDataWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves an export for the given node.
     * Retrieves an export for the given node. The export contains the node, including its path and value, and all of its children. Exports are useful for saving snapshots of a given node and subsequently restoring them.
     * @param nodePath The path of the node whose data will be exported (with ~ instead of /).
     */
    public getNodeExport(nodePath: string, extraHttpRequestParams?: any): Observable<models.NodeExport> {
        return this.getNodeExportWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Imports a previously obtained export into the given node.
     * Imports a previously obtained export into the given node. It is possible to specify whether the value of already existing nodes should be overwritten, and whether the import should prune nodes existing in ZooKeeper that do not exist in the export.
     * @param nodePath The path of the node whose data will be restored (with ~ instead of /).
     * @param prune Indicates whether the import should prune nodes existing in ZooKeeper that do not exist in the export. The default is &#x60;false&#x60;.
     * @param overwrite Indicates whether the value of already existing nodes should be overwritten. The default is &#x60;true&#x60;.
     * @param node The node export that will be restored into the specified path.
     */
    public restoreNodeExport(nodePath: string, prune?: boolean, overwrite?: boolean, node?: models.NodeExport, extraHttpRequestParams?: any): Observable<{}> {
        return this.restoreNodeExportWithHttpInfo(nodePath, prune, overwrite, node, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Sets the data of the given data node.
     * Sets the data of the given data node.
     * @param nodePath The path of the node whose data will be set  (with ~ instead of /).
     * @param nodeData The data to set to the given node.
     */
    public setNodeData(nodePath: string, nodeData?: models.NodeData, extraHttpRequestParams?: any): Observable<{}> {
        return this.setNodeDataWithHttpInfo(nodePath, nodeData, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Creates a new child of the given data node.
     * Creates a new child of the given data node.
     * @param nodePath The path of the node that will be added a child (with ~ instead of /).
     * @param body The data of the new node (name and value).
     */
    public addNodeChildWithHttpInfo(nodePath: string, body?: models.NodeCreationRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}/children'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling addNodeChild.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deletes the given data node.
     * Deletes the given data node.
     * @param nodePath The path of the node whose data will be deleted  (with ~ instead of /).
     */
    public deleteNodeWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling deleteNode.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves the children of the given data node.
     * Retrieves the children of the given data node.
     * @param nodePath The path of the node whose children will be retrieved (with ~ instead of /).
     */
    public getNodeChildrenWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}/children'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeChildren.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves the data of the given data node.
     * Retrieves the data of the given data node.
     * @param nodePath The path of the node whose data will be retrieved  (with ~ instead of /).
     */
    public getNodeDataWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeData.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves an export for the given node.
     * Retrieves an export for the given node. The export contains the node, including its path and value, and all of its children. Exports are useful for saving snapshots of a given node and subsequently restoring them.
     * @param nodePath The path of the node whose data will be exported (with ~ instead of /).
     */
    public getNodeExportWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}/export'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeExport.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Imports a previously obtained export into the given node.
     * Imports a previously obtained export into the given node. It is possible to specify whether the value of already existing nodes should be overwritten, and whether the import should prune nodes existing in ZooKeeper that do not exist in the export.
     * @param nodePath The path of the node whose data will be restored (with ~ instead of /).
     * @param prune Indicates whether the import should prune nodes existing in ZooKeeper that do not exist in the export. The default is &#x60;false&#x60;.
     * @param overwrite Indicates whether the value of already existing nodes should be overwritten. The default is &#x60;true&#x60;.
     * @param node The node export that will be restored into the specified path.
     */
    public restoreNodeExportWithHttpInfo(nodePath: string, prune?: boolean, overwrite?: boolean, node?: models.NodeExport, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}/export'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling restoreNodeExport.');
        }
        if (prune !== undefined) {
            queryParameters.set('prune', <any>prune);
        }

        if (overwrite !== undefined) {
            queryParameters.set('overwrite', <any>overwrite);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: node == null ? '' : JSON.stringify(node), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Sets the data of the given data node.
     * Sets the data of the given data node.
     * @param nodePath The path of the node whose data will be set  (with ~ instead of /).
     * @param nodeData The data to set to the given node.
     */
    public setNodeDataWithHttpInfo(nodePath: string, nodeData?: models.NodeData, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling setNodeData.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: nodeData == null ? '' : JSON.stringify(nodeData), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
