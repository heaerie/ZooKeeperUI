import { NodeDataType } from '../autogenerated/model/NodeDataType';

const pathSeparator: string = '~~';

export class Node {
  public path: string;
  public name: string;
  public value: string;
  public type: NodeDataType;
  private _children: Node[];
  private _parent: Node;
  public static ROOT_NODE_PATH = pathSeparator;

  constructor(path: string, parent?: Node) {
    this.path = path;
    this.name = Node.getNodeNameFromPath(path);
    this._children = [];
    this._parent = parent;
    this.type = NodeDataType.String;
  }

  private getChildNodePath(child: string): string {
    let result: string = this.path;
    if (!result.endsWith(pathSeparator))
      result += pathSeparator;
    result += child;
    return result;
  }

  private static getNodeNameFromPath(path: string): string {
    let pathSegments = path.split(pathSeparator).filter(pathSegment => pathSegment.length > 0);
    if (pathSegments.length > 0) {
      return pathSegments[pathSegments.length - 1];
    } else {
      return 'Root';
    }
  }

  addChildNode(child: string): Node {
    let childNode = new Node(this.getChildNodePath(child), this);
    this._children.push(childNode);
    this._children.sort((a, b) => a.name.localeCompare(b.name));
    return childNode;
  }

  clearChildren(): void {
    this._children = [];
  }

  get hasChildren(): boolean {
    return this._children.length > 0;
  }

  get children(): Node[] {
    return this._children;
  }

  delete(): void {
    if (this._parent === undefined)
      return;

    let i = this._parent.children.indexOf(this);
    if(i != -1) {
      this._parent.children.splice(i, 1);
    }
  }

  get parents(): Node[] {
    let parents: Node[] = [];
    let parentPath: string = pathSeparator;
    parents.push(new Node(Node.ROOT_NODE_PATH));

    let pathSegments = this.path.split(pathSeparator).filter(pathSegment => pathSegment.length > 0);;

    for (let pathSegment of pathSegments) {
      parentPath += pathSegment;
      parents.push(new Node(parentPath));
    }
    return parents;
  }
}
