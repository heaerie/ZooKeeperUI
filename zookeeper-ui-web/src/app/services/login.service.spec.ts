import { TestBed, inject } from '@angular/core/testing';

import { LoginService } from './login.service';
import { SessionsApi } from '../autogenerated/api/SessionsApi';
import { Router } from '@angular/router';

import { Observable } from 'rxjs';

describe('LoginService', () => {
  let loginService: LoginService;
  let sessionsApi: SessionsApi = new SessionsApi(null, null, null);
  let routerStub: any = {
    navigate: function(path: string) {}
  };

  beforeEach(() => {
  });

  it('should create new session in the sessions api with the given user name and password when logging a user in', () => {
    let testUserName = 'test_user';
    let testPassword = 'TestPassword.';
    let createNewSessionSpy = spyOn(sessionsApi, 'createNewUserSession')
      .and.returnValue(Observable.of( { expirationSeconds: 1800 } ));
    let getSessionInfoSpy = spyOn(sessionsApi, 'getSessionInfo')
        .and.returnValue(Observable.never());

    loginService = new LoginService(sessionsApi, routerStub as Router);
    loginService.logIn(testUserName, testPassword);
    expect(sessionsApi.createNewUserSession).toHaveBeenCalledWith({
      userName: testUserName,
      password: testPassword
    });
  });

  it('should, on a successful login, notify that the user is logged in', (done) => {
    let testUserName = 'test_user';
    let testPassword = 'TestPassword.';
    let createNewSessionSpy = spyOn(sessionsApi, 'createNewUserSession')
      .and.returnValue(Observable.of({ expirationSeconds: 1800 }));
    let getSessionInfoSpy = spyOn(sessionsApi, 'getSessionInfo')
        .and.returnValue(Observable.never());

    loginService = new LoginService(sessionsApi, routerStub as Router);
    loginService.loggedInObservable.subscribe(loggedIn => {
      if (loggedIn) {
        done();
      }
    });

    loginService.logIn(testUserName, testPassword);
  });

  it('should notify that the user is logged in when detecting an already open session on start', (done) => {
    let getSessionInfoSpy = spyOn(sessionsApi, 'getSessionInfo')
        .and.returnValue(Observable.of({ expirationSeconds: 1800 }));

    loginService.loggedInObservable.subscribe(loggedIn => {
      if (loggedIn) {
        done();
      }
    });
    loginService = new LoginService(sessionsApi, routerStub as Router);
  });

  it('should close the ongoing session in the sessions api when logging the user out', () => {
    let closeSessionStub = spyOn(sessionsApi, 'closeSession')
      .and.returnValue(Observable.of({}));
    let getSessionInfoSpy = spyOn(sessionsApi, 'getSessionInfo')
      .and.returnValue(Observable.never());

    loginService = new LoginService(sessionsApi, routerStub as Router);
    loginService.logOut();
    expect(sessionsApi.closeSession).toHaveBeenCalled();
  });

  it('should notify that the user is logged out and redirect to the login page when successfully logging the user out', (done) => {
    let logOutInvoked: boolean = false;
    let closeSessionStub = spyOn(sessionsApi, 'closeSession')
      .and.returnValue(Observable.of({}));
    let getSessionInfoSpy = spyOn(sessionsApi, 'getSessionInfo')
      .and.returnValue(Observable.never());
    let routerNavigateSpy = spyOn(routerStub as Router, 'navigate');

    loginService = new LoginService(sessionsApi, routerStub as Router);
    loginService.loggedInObservable.subscribe(loggedIn => {
      if (logOutInvoked) {
        expect(loggedIn).toBeFalsy();
        expect((routerStub as Router).navigate).toHaveBeenCalledWith(['/login']);
        done();
      }
    });

    logOutInvoked = true;
    loginService.logOut();
  });
});
